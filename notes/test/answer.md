#### 답

이벤트델리게이션을 통한 이벤트 등록은 여러개의 이벤트리스너를 만들지 않아 메모리 효율성이 있는 장점이 있음.

델리게이션을 이용한 원리는, 버블링(이벤트전파)이라는 특성을 활용한 것이다.

a -> li -> ul > div 와 같은 dom tree가 있을때, a를 클릭하는 순간, 각각 4개의 dom tree에 바인딩된 이벤트리스너가 있는지 탐색하고 있다면

해당 이벤트리스너를 실행하게 된다.  만약 div에만 이벤트리스너를 등록했다고 가정하면, div의 리스너가 실행되고, 그때의 event target은 실제 눌러진 a  태그를 가리킨다. 만약 li를 클릭했다고 해도 마찬가지다. 이때도 li -> ul>div 버블링이 일어나고, div에 바인딩된 이벤트리스너가 실행되며 그때의 event 객체의 target은 li태그를 가리키게 된다. 

이벤트델리게이션은 이벤트의 버블링이라는 특성을 잘 활용한 방법이라고 할 수 있다.

또한 동적으로 추가되는 엘리먼트에 별도의 핸드러를 등록하지 않아도 되는 장점이 있음.

 

그리고 버블링과 캡쳐링은 다름. 보통 버블링이 기본값임으로(addeventlistener의 마지막 인자로 이를 설정가능) 자식노드에서 위쪽으로 탐색이 시작됨.

 

---

prototype객체는 공유된다. 메모리 효율성을 올릴 수 있는 장점이 있다.

prototype이라는 객체는 일종의 상속의 개념과 유사하다고 볼수도 있다.

따라서 인스턴스마다 재사용이 필요한 메서드들은 prototype의 속성으로 추가하는 것이 효율적이다. 

---

bind메서드는 this키워드가 변경되는 것을 방지하는 것이 아니고, this키워드가 가리키는 context를 원하는대로 변경시킬 수 있는 메서드이다.

bind의 첫번째 인자로 원하는 context를 지정하면 된다.

apply와  call은 context를 직시 변경해서 함수를 실행하는 것으로, bind와 완전히 다르게 동작함. 

---

비동기콜백함수들은 stack이 비워져 있을때, stack공간에 올라와서 실행된다.